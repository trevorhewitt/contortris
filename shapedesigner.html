<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shape Designer</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; max-width: 1200px; }
    .grid { display: grid; grid-template-columns: 1.25fr 0.75fr; gap: 14px; align-items: start; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; }
    label { display: block; font-weight: 650; margin: 10px 0 6px; }
    input[type="text"], textarea, input[type="number"] {
      width: 100%; box-sizing: border-box; padding: 10px; border-radius: 10px; border: 1px solid #ccc;
      font-size: 14px;
    }
    textarea {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      resize: vertical;
      min-height: 5.5em; /* ~5 lines */
      line-height: 1.1;
      white-space: pre;
    }
    .topControls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .inline { display: flex; gap: 12px; align-items: center; }
    .inline > * { flex: 1; }
    button {
      padding: 10px 14px; border-radius: 12px; border: 1px solid #bbb; background: #f7f7f7; cursor: pointer;
      font-weight: 650;
    }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .muted { color: #555; font-size: 13px; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .error {
      margin-top: 10px; padding: 10px; border-radius: 10px;
      background: #fff5f5; border: 1px solid #f2b8b8; color: #7a1f1f;
      display: none; white-space: pre-wrap;
    }

    /* Preview */
    .editorGrid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: start; }
    .previewWrap { display: grid; gap: 8px; }
    .preview {
      display: grid; gap: 2px; justify-content: start;
      padding: 10px; border: 1px dashed #ccc; border-radius: 12px; background: #fff;
      min-height: 90px;
    }
    .cell { width: 18px; height: 18px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.05); }
    .cell.off { background: transparent; border-color: rgba(0,0,0,0.04); }
    .cell.on { background: var(--on); }

    /* Slider */
    .sliderWrap { display: grid; gap: 6px; }
    input[type="range"] {
      width: 100%;
      height: 32px; margin: 0;
      touch-action: none;
      cursor: pointer;
    }

    /* Right panel */
    .rightHeader { display: flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .recentControls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px; }
    .recentControls .inline { gap: 8px; }
    .recentList { display: grid; gap: 10px; margin-top: 12px; }
    .item {
      border: 1px solid #eee; border-radius: 12px; padding: 10px;
      background: #fafafa; display: grid; gap: 8px;
      cursor: pointer;
    }
    .item:hover { border-color: #ddd; }
    .itemHead { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: start; }
    .itemName { font-weight: 750; }
    .itemMeta { color: #666; font-size: 12px; }
    .itemStats { color: #555; font-size: 12px; text-align: right; }
    .miniPreview { display: grid; gap: 2px; justify-content: start; }
    .miniCell { width: 12px; height: 12px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.05); }
    .miniCell.off { background: transparent; border-color: rgba(0,0,0,0.04); }
    .miniCell.on { background: var(--on); }

    /* Bottom controls */
    .bottomControls { margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .fileMeta { padding: 10px; border-radius: 10px; border: 1px solid #eee; background: #fafafa; }
  </style>
</head>

<body>
  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="topControls">
        <div>
          <label for="shapeName">Shape name</label>
          <input id="shapeName" type="text" placeholder="e.g., the donut" />
        </div>

        <div>
          <label>Colour</label>
          <div class="inline">
            <input id="shapeColor" type="color" value="#ff00e6" />
            <div class="mono" id="shapeColorHex">#ff00e6</div>
          </div>
        </div>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div class="sliderWrap">
          <label for="shapeFreq">Frequency: <span class="mono" id="freqVal">1.00</span></label>
          <input id="shapeFreq" type="range" min="0" max="1" step="0.01" value="1.00" />
          <div class="muted">0.00–1.00</div>
        </div>

        <div style="display:grid; align-content:end;">
          <button id="saveBtn" class="primary" disabled>Save shape</button>
          <div class="muted" style="margin-top:8px;">
            Save updates the right panel. Click any shape there to load it for editing.
          </div>
        </div>
      </div>

      <div class="editorGrid" style="margin-top:14px;">
        <div>
          <label for="shapeGrid">Grid (<span class="mono">X</span> filled, <span class="mono">.</span>/<span class="mono">space</span> empty)</label>
          <textarea id="shapeGrid" rows="5" placeholder="XXX&#10;X.X&#10;XXX"></textarea>
          <div class="muted">Spaces are treated as dots; shorter rows are padded with dots.</div>
        </div>

        <div class="previewWrap">
          <label>Live preview</label>
          <div id="preview" class="preview" aria-label="Shape preview"></div>
          <div class="muted mono" id="previewDims"></div>
        </div>
      </div>

      <div class="error" id="errorBox"></div>

      <!-- Bottom: less-used controls -->
      <div class="bottomControls">
        <div>
          <label for="shapeId">Shape id (optional)</label>
          <input id="shapeId" type="text" placeholder="(auto-suggested from name)" />
          <div class="muted">Auto-suggest: longest word in name (ties resolved by later words), lowercased.</div>
        </div>

        <div>
          <label>Target file</label>
          <div class="inline">
            <button id="pickFileBtn">Pick file…</button>
            <button id="reloadBtn" disabled>Reload</button>
          </div>
          <div class="fileMeta">
            <div><b>Selected:</b> <span id="fileName" class="mono">None</span></div>
            <div class="muted" id="fileInfo">Default path: <span class="mono">./shapes/main_shapes.js</span> (loads for browsing if served).</div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="rightHeader">
        <div style="font-weight:800;">Shapes</div>
        <div class="muted"><span id="shapeCount">0</span> total</div>
      </div>

      <div class="recentControls">
        <div>
          <label for="pageSize">Show</label>
          <input id="pageSize" type="number" min="5" max="200" step="5" value="25" />
        </div>
        <div>
          <label>Page</label>
          <div class="inline">
            <button id="prevPageBtn">Prev</button>
            <button id="nextPageBtn">Next</button>
          </div>
        </div>
        <div>
          <label>Status</label>
          <div class="fileMeta">
            <div class="mono" id="pageLabel">Page 1 / 1</div>
            <div class="muted">Newest first</div>
          </div>
        </div>
      </div>

      <div id="recentList" class="recentList"></div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // -----------------------------
  // State
  // -----------------------------
  let fileHandle = null;      // for in-place writing
  let loadedText = null;      // file contents
  let loadedShapes = null;    // parsed SHAPES array

  const DEFAULT_REL_PATH = "./shapes/main_shapes.js";
  const HANDLE_DB_NAME = "shape_designer_fs_handles";
  const HANDLE_DB_STORE = "handles";
  const HANDLE_KEY = "shapesFileHandle";

  let currentFreq = 1.0;      // authoritative frequency value (fixes “always 1” issues)
  let pageIndex = 0;          // 0-based
  let pageSize = 25;

  // -----------------------------
  // UI helpers
  // -----------------------------
  function showError(msg) {
    const el = $("errorBox");
    if (!msg) { el.style.display = "none"; el.textContent = ""; return; }
    el.style.display = "block";
    el.textContent = msg;
  }

  function escapeHtml(str) {
    return String(str).replace(/[&<>"']/g, (m) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  function normaliseNewlines(s) {
    return s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  }

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

  function suggestIdFromName(name) {
    const parts = name
      .trim()
      .split(/\s+/)
      .filter(Boolean)
      .map(w => w.replace(/[^A-Za-z0-9_'-]/g, ""))
      .filter(Boolean);

    if (parts.length === 0) return "";

    let best = parts[0];
    for (const w of parts) {
      if (w.length > best.length) best = w;
      else if (w.length === best.length) best = w; // later wins
    }
    return best.toLowerCase().replace(/['-]/g, "").replace(/[^a-z0-9_]/g, "_");
  }

  // Spaces become dots; shorter rows padded with dots
  function parseGridTextarea(text) {
    const lines = normaliseNewlines(text)
      .split("\n")
      .map(l => l.replace(/\t/g, " "))
      .map(l => l.replace(/\s+$/g, ""))
      .filter(l => l.trim().length > 0);

    if (lines.length === 0) throw new Error("Grid is empty.");

    for (const line of lines) {
      if (!/^[X. ]+$/.test(line)) {
        throw new Error("Grid contains invalid characters. Use only 'X', '.', and spaces.");
      }
    }

    const maxW = Math.max(...lines.map(l => l.length));
    return lines.map(l => l.replace(/ /g, ".").padEnd(maxW, "."));
  }

  // -----------------------------
  // Preview rendering
  // -----------------------------
  function renderPreview(grid, color) {
    const preview = $("preview");
    preview.innerHTML = "";
    preview.style.setProperty("--on", color);

    const rows = grid.length;
    const cols = grid[0].length;

    preview.style.gridTemplateColumns = `repeat(${cols}, 18px)`;
    preview.style.gridTemplateRows = `repeat(${rows}, 18px)`;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.className = "cell " + (grid[r][c] === "X" ? "on" : "off");
        preview.appendChild(cell);
      }
    }
    $("previewDims").textContent = `${cols}×${rows}`;
  }

  function clearPreview() {
    $("preview").innerHTML = "";
    $("previewDims").textContent = "";
  }

  function liveUpdatePreview() {
    const color = $("shapeColor").value.toLowerCase();
    const gridText = $("shapeGrid").value;

    if (!gridText.trim()) { clearPreview(); showError(""); return; }

    try {
      const grid = parseGridTextarea(gridText);
      renderPreview(grid, color);
      showError("");
    } catch (e) {
      clearPreview();
      showError(e.message || String(e));
    }
  }

  // -----------------------------
  // Right panel: pagination + list
  // -----------------------------
  function renderMiniPreview(container, grid, color) {
    container.innerHTML = "";
    container.style.setProperty("--on", color);

    const rows = grid.length;
    const cols = grid[0].length;
    container.style.gridTemplateColumns = `repeat(${cols}, 12px)`;
    container.style.gridTemplateRows = `repeat(${rows}, 12px)`;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.className = "miniCell " + (grid[r][c] === "X" ? "on" : "off");
        container.appendChild(cell);
      }
    }
  }

  function getShapesNewestFirst() {
    const shapes = Array.isArray(loadedShapes) ? loadedShapes : [];
    return shapes.slice().reverse();
  }

  function updatePaginationLabel(total) {
    const pageCount = Math.max(1, Math.ceil(total / pageSize));
    pageIndex = clamp(pageIndex, 0, pageCount - 1);
    $("pageLabel").textContent = `Page ${pageIndex + 1} / ${pageCount}`;

    $("prevPageBtn").disabled = (pageIndex === 0);
    $("nextPageBtn").disabled = (pageIndex >= pageCount - 1);
  }

  function updateListPanel() {
    const list = $("recentList");
    list.innerHTML = "";

    const newest = getShapesNewestFirst();
    $("shapeCount").textContent = String(newest.length);

    updatePaginationLabel(newest.length);

    if (newest.length === 0) {
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No shapes loaded yet.";
      list.appendChild(empty);
      return;
    }

    const start = pageIndex * pageSize;
    const end = Math.min(newest.length, start + pageSize);
    const pageItems = newest.slice(start, end);

    for (const s of pageItems) {
      const item = document.createElement("div");
      item.className = "item";
      item.title = "Click to load into editor";

      const head = document.createElement("div");
      head.className = "itemHead";

      const left = document.createElement("div");
      left.innerHTML = `
        <div class="itemName">${escapeHtml(s.name || "(unnamed)")}</div>
        <div class="itemMeta mono">id: ${escapeHtml(s.id || "(none)")}</div>
      `;

      const cols = (s.grid && s.grid[0]) ? s.grid[0].length : 0;
      const rows = (s.grid && s.grid.length) ? s.grid.length : 0;
      const freq = (typeof s.frequency === "number") ? s.frequency : Number(s.frequency);
      const freqText = (Number.isFinite(freq)) ? freq.toFixed(2) : "—";

      const right = document.createElement("div");
      right.className = "itemStats mono";
      right.innerHTML = `${cols}×${rows}<br/>f=${freqText}`;

      head.appendChild(left);
      head.appendChild(right);

      const mini = document.createElement("div");
      mini.className = "miniPreview";
      if (Array.isArray(s.grid) && s.grid.length > 0) {
        renderMiniPreview(mini, s.grid, (s.color || "#000000").toLowerCase());
      }

      item.appendChild(head);
      item.appendChild(mini);

      item.addEventListener("click", () => loadShapeIntoEditor(s));

      list.appendChild(item);
    }
  }

  function loadShapeIntoEditor(shape) {
    $("shapeName").value = shape.name ?? "";
    $("shapeId").value = shape.id ?? "";
    $("shapeColor").value = (shape.color || "#000000").toLowerCase();
    $("shapeColorHex").textContent = $("shapeColor").value.toLowerCase();

    const freq = clamp(Number(shape.frequency ?? 1), 0, 1);
    currentFreq = freq;
    $("shapeFreq").value = String(freq);
    $("freqVal").textContent = freq.toFixed(2);

    const grid = Array.isArray(shape.grid) ? shape.grid : [];
    $("shapeGrid").value = grid.join("\n");

    liveUpdatePreview();
    showError("");
  }

  // -----------------------------
  // Parsing / serialising shapes.js
  // -----------------------------
  function findMatchingBracket(s, openPos, openCh, closeCh) {
    let depth = 0;
    let inStr = false;
    let strCh = null;
    let escape = false;

    for (let i = openPos; i < s.length; i++) {
      const c = s[i];

      if (inStr) {
        if (escape) { escape = false; continue; }
        if (c === "\\") { escape = true; continue; }
        if (c === strCh) { inStr = false; strCh = null; }
        continue;
      } else {
        if (c === "'" || c === '"' || c === "`") { inStr = true; strCh = c; continue; }
      }

      if (c === openCh) depth++;
      else if (c === closeCh) {
        depth--;
        if (depth === 0) return i;
      }
    }
    return -1;
  }

  function extractAndEvalShapes(jsText) {
    const text = normaliseNewlines(jsText);
    const m = text.match(/export\s+const\s+SHAPES\s*=\s*\[/m);
    if (!m) throw new Error("Could not find `export const SHAPES = [` in the file.");

    const startIdx = m.index + m[0].length - 1;
    const endIdx = findMatchingBracket(text, startIdx, "[", "]");
    if (endIdx < 0) throw new Error("Could not find the end of the SHAPES array.");

    const arrayLiteral = text.slice(startIdx, endIdx + 1);

    let shapes;
    try {
      shapes = (new Function(`"use strict"; return (${arrayLiteral});`))();
    } catch (e) {
      throw new Error("SHAPES exists but could not be evaluated (non-literal code inside array?).");
    }

    if (!Array.isArray(shapes)) throw new Error("Parsed SHAPES is not an array.");
    return shapes;
  }

  function jsString(s) {
    const esc = String(s)
      .replace(/\\/g, "\\\\")
      .replace(/'/g, "\\'")
      .replace(/\n/g, "\\n");
    return `'${esc}'`;
  }

  function jsObject(obj) {
    if (obj && typeof obj === "object" && !Array.isArray(obj)) {
      const entries = Object.entries(obj).map(([k,v]) => {
        if (typeof v === "string") return `${k}: ${jsString(v)}`;
        if (typeof v === "number") return `${k}: ${v}`;
        if (typeof v === "boolean") return `${k}: ${v}`;
        return `${k}: ${jsString(String(v))}`;
      });
      return `{ ${entries.join(", ")} }`;
    }
    return "{}";
  }

  function serialiseShapes(shapes) {
    const ordered = shapes.map(s => ({
      id: s.id,
      name: s.name,
      grid: s.grid,
      color: s.color,
      difficulty: s.difficulty,
      rotation: s.rotation,
      frequency: s.frequency,
    }));

    const lines = [];
    lines.push("export const SHAPES = [");

    for (const shape of ordered) {
      const freq = clamp(Number(shape.frequency ?? 1), 0, 1);
      lines.push("  {");
      lines.push(`    id: ${jsString(shape.id)},`);
      lines.push(`    name: ${jsString(shape.name)},`);
      lines.push("    grid: [");
      for (const row of shape.grid) lines.push(`      ${jsString(row)},`);
      lines.push("    ],");
      lines.push(`    color: ${jsString(shape.color)},`);
      lines.push(`    difficulty: ${Number(shape.difficulty)},`);
      lines.push(`    rotation: ${jsObject(shape.rotation)},`);
      lines.push(`    frequency: ${freq.toFixed(2)},`);
      lines.push("  },");
    }

    lines.push("];");
    lines.push("");
    return lines.join("\n");
  }

  function replaceShapesArrayInText(originalText, newShapesFileContent) {
    const text = normaliseNewlines(originalText);
    const re = /export\s+const\s+SHAPES\s*=\s*\[[\s\S]*?\]\s*;\s*/m;
    if (re.test(text)) return text.replace(re, newShapesFileContent);
    return newShapesFileContent;
  }

  // -----------------------------
  // File I/O
  // -----------------------------
  async function loadFromText(text, fileLabel) {
    loadedText = text;
    loadedShapes = extractAndEvalShapes(text);
    $("fileName").textContent = fileLabel || "Loaded";
    $("fileInfo").textContent = `Loaded ${loadedShapes.length} shape(s).`;
    updateListPanel();
    $("saveBtn").disabled = !fileHandle; // fast save requires a handle
  }

  async function tryFetchDefaultForBrowsing() {
    // Works only if served (not file://) and the file exists at ./shapes/main_shapes.js
    try {
      const res = await fetch(DEFAULT_REL_PATH, { cache: "no-store" });
      if (!res.ok) return;
      const text = await res.text();
      await loadFromText(text, DEFAULT_REL_PATH);
    } catch (_) {}
  }

  async function writeBack(updatedText) {
    // In-place if possible; otherwise download
    if (fileHandle && fileHandle.createWritable) {
      try {
        const writable = await fileHandle.createWritable();
        await writable.write(updatedText);
        await writable.close();
        return { method: "in_place" };
      } catch (_) {}
    }

    const blob = new Blob([updatedText], { type: "text/javascript;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = fileHandle ? fileHandle.name : "main_shapes.js";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    return { method: "download" };
  }

  async function pickFile() {
    if (!window.showOpenFilePicker) {
      alert("Use Chrome/Edge for direct writing. Otherwise you can still browse the default file if served, but saving will be download-only.");
      return;
    }
    const [handle] = await window.showOpenFilePicker({
      multiple: false,
      types: [{ description: "JavaScript files", accept: { "text/javascript": [".js"] } }]
    });
    fileHandle = handle;
    await persistHandle(handle);
    await reloadFromFile();
    $("reloadBtn").disabled = false;
    $("saveBtn").disabled = false;
  }

  async function reloadFromFile() {
    if (!fileHandle) throw new Error("No file selected.");
    const file = await fileHandle.getFile();
    const text = await file.text();
    await loadFromText(text, fileHandle.name);
  }

  // -----------------------------
  // Persist file handle
  // -----------------------------
  function openHandleDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(HANDLE_DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(HANDLE_DB_STORE)) db.createObjectStore(HANDLE_DB_STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function persistHandle(handle) {
    try {
      const db = await openHandleDb();
      await new Promise((resolve, reject) => {
        const tx = db.transaction(HANDLE_DB_STORE, "readwrite");
        tx.objectStore(HANDLE_DB_STORE).put(handle, HANDLE_KEY);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
      db.close();
    } catch (_) {}
  }

  async function restoreHandleIfPossible() {
    if (!window.showOpenFilePicker) return false;
    try {
      const db = await openHandleDb();
      const handle = await new Promise((resolve, reject) => {
        const tx = db.transaction(HANDLE_DB_STORE, "readonly");
        const req = tx.objectStore(HANDLE_DB_STORE).get(HANDLE_KEY);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
      db.close();
      if (!handle) return false;

      let perm = await handle.queryPermission({ mode: "readwrite" });
      if (perm !== "granted") perm = await handle.requestPermission({ mode: "readwrite" });
      if (perm !== "granted") return false;

      fileHandle = handle;
      await reloadFromFile();
      $("reloadBtn").disabled = false;
      $("saveBtn").disabled = false;
      return true;
    } catch (_) {
      return false;
    }
  }

  // -----------------------------
  // Conflicts
  // -----------------------------
  function hasConflicts(shapes, newShape) {
    const idConflict = shapes.find(s => s.id === newShape.id) || null;
    const nameConflict = shapes.find(s => s.name === newShape.name) || null;
    const gridConflict = shapes.find(s => JSON.stringify(s.grid) === JSON.stringify(newShape.grid)) || null;
    return { idConflict, nameConflict, gridConflict };
  }

  async function resolveConflictsAndApply(shapes, newShape) {
    const { idConflict, nameConflict, gridConflict } = hasConflicts(shapes, newShape);
    if (!idConflict && !nameConflict && !gridConflict) {
      return { action: "add", shapes: [...shapes, newShape] };
    }

    const parts = [];
    if (idConflict) parts.push(`• ID already exists: "${newShape.id}"`);
    if (nameConflict) parts.push(`• Name already exists: "${newShape.name}"`);
    if (gridConflict) parts.push("• Grid already exists (same pattern as an existing shape)");
    const msg =
      "Conflict detected:\n\n" + parts.join("\n") +
      "\n\nOK = override\nCancel = choose Add/cancel";

    const okOverride = window.confirm(msg);
    if (okOverride) {
      const updated = shapes.map(s => {
        if (idConflict && s.id === newShape.id) return newShape;
        if (!idConflict && nameConflict && s.name === newShape.name) return newShape;
        if (!idConflict && !nameConflict && gridConflict && JSON.stringify(s.grid) === JSON.stringify(newShape.grid)) return newShape;
        return s;
      });
      return { action: "override", shapes: updated };
    }

    const okAdd = window.confirm("Add anyway?\n\nOK = add\nCancel = cancel");
    if (!okAdd) return { action: "cancel", shapes };
    return { action: "add_anyway", shapes: [...shapes, newShape] };
  }

  // -----------------------------
  // Build shape from UI (frequency fix)
  // -----------------------------
  function buildShapeFromUI() {
    const grid = parseGridTextarea($("shapeGrid").value);

    const name = $("shapeName").value.trim() || "(unnamed)";
    let id = $("shapeId").value.trim();

    if (!id) {
      id = suggestIdFromName(name);
      if (!id || id === "unnamed") throw new Error("Please provide a shape id (auto-id is not useful for an empty/unnamed name).");
    }

    if (!/^[a-z0-9_]+$/.test(id)) throw new Error("ID must contain only lowercase letters, numbers, and underscores.");

    const color = $("shapeColor").value.toLowerCase();
    if (!/^#[0-9a-f]{6}$/.test(color)) throw new Error("Colour must be a 6-digit hex value.");

    // IMPORTANT: use currentFreq (kept in sync with slider) rather than trusting element.value
    const freq = clamp(Number(currentFreq), 0, 1);

    return {
      id,
      name,
      grid,
      color,
      difficulty: 1,
      rotation: { mode: "any" },
      frequency: freq,
    };
  }

  // -----------------------------
  // Slider robustness
  // -----------------------------
  function enhanceRangeDragging(rangeEl) {
    rangeEl.addEventListener("pointerdown", (e) => {
      try { rangeEl.setPointerCapture(e.pointerId); } catch (_) {}
    });
    rangeEl.addEventListener("pointerup", (e) => {
      try { rangeEl.releasePointerCapture(e.pointerId); } catch (_) {}
    });
  }

  function syncFreqFromSlider() {
    const v = clamp(parseFloat($("shapeFreq").value), 0, 1);
    currentFreq = Number.isFinite(v) ? v : 1.0;
    $("freqVal").textContent = currentFreq.toFixed(2);
  }

  // -----------------------------
  // Events
  // -----------------------------
  $("shapeColor").addEventListener("input", () => {
    $("shapeColorHex").textContent = $("shapeColor").value.toLowerCase();
    liveUpdatePreview();
  });

  $("shapeGrid").addEventListener("input", liveUpdatePreview);

  $("shapeName").addEventListener("input", () => {
    const name = $("shapeName").value.trim();
    const idField = $("shapeId");
    if (!idField.value.trim() && name) idField.placeholder = suggestIdFromName(name) || "(auto-suggested from name)";
  });

  $("shapeFreq").addEventListener("input", syncFreqFromSlider);
  $("shapeFreq").addEventListener("change", syncFreqFromSlider);
  enhanceRangeDragging($("shapeFreq"));

  $("pageSize").addEventListener("input", () => {
    const v = clamp(parseInt($("pageSize").value, 10) || 25, 5, 200);
    pageSize = v;
    $("pageSize").value = String(v);
    pageIndex = 0;
    updateListPanel();
  });

  $("prevPageBtn").addEventListener("click", () => {
    pageIndex = Math.max(0, pageIndex - 1);
    updateListPanel();
  });

  $("nextPageBtn").addEventListener("click", () => {
    const total = getShapesNewestFirst().length;
    const pageCount = Math.max(1, Math.ceil(total / pageSize));
    pageIndex = Math.min(pageCount - 1, pageIndex + 1);
    updateListPanel();
  });

  $("pickFileBtn").addEventListener("click", async () => {
    try { await pickFile(); showError(""); }
    catch (e) { showError(e.message || String(e)); }
  });

  $("reloadBtn").addEventListener("click", async () => {
    try { await reloadFromFile(); showError(""); }
    catch (e) { showError(e.message || String(e)); }
  });

  $("saveBtn").addEventListener("click", async () => {
    try {
      if (!loadedText || !loadedShapes) throw new Error("No shapes loaded. Pick a file (or serve the project so default loads).");

      const newShape = buildShapeFromUI();
      const resolved = await resolveConflictsAndApply(loadedShapes, newShape);
      if (resolved.action === "cancel") return;

      const newShapesBlock = serialiseShapes(resolved.shapes);
      const updatedText = replaceShapesArrayInText(loadedText, newShapesBlock);

      await writeBack(updatedText);

      // Update in-memory state immediately; show newest-first list with new shape at top
      await loadFromText(updatedText, fileHandle ? fileHandle.name : (DEFAULT_REL_PATH + " (updated)"));
      pageIndex = 0;
      updateListPanel();
      showError("");
    } catch (e) {
      showError(e.message || String(e));
    }
  });

  // -----------------------------
  // Boot
  // -----------------------------
  (async () => {
    $("shapeColorHex").textContent = $("shapeColor").value.toLowerCase();
    syncFreqFromSlider();

    const restored = await restoreHandleIfPossible();
    if (!restored) {
      await tryFetchDefaultForBrowsing();
      $("saveBtn").disabled = true; // enable after picking a file handle
      $("fileInfo").textContent =
        "Browse works if served and ./shapes/main_shapes.js is reachable. Pick the file once to enable fast in-place saving (no re-select).";
    }

    updateListPanel();
    liveUpdatePreview();
  })();
})();
</script>
</body>
</html>