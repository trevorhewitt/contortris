<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shape Builder Advanced</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; max-width: 1400px; background: #0b0b0b; color: #eaeaea; }
    .grid { display: grid; grid-template-columns: 1.4fr 0.6fr; gap: 14px; align-items: start; }
    .card {
      border: 1px solid #232323; border-radius: 12px; padding: 14px;
      background: #111; box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset;
    }
    label { display: block; font-weight: 650; margin: 10px 0 6px; color: #eaeaea; }
    input[type="text"], input[type="number"], select {
      width: 100%; box-sizing: border-box; padding: 10px; border-radius: 10px;
      border: 1px solid #2a2a2a; background: #0d0d0d; color: #eaeaea; font-size: 14px;
    }
    input[type="color"] { width: 56px; height: 36px; padding: 0; border-radius: 10px; border: 1px solid #2a2a2a; background: #0d0d0d; }
    button {
      padding: 10px 14px; border-radius: 12px; border: 1px solid #2a2a2a; background: #151515; color: #eaeaea;
      cursor: pointer; font-weight: 650;
    }
    button.primary { background: #eaeaea; color: #0b0b0b; border-color: #eaeaea; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .muted { color: #a9a9a9; font-size: 13px; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .error {
      margin-top: 10px; padding: 10px; border-radius: 10px;
      background: #1a0f10; border: 1px solid #5a2a2c; color: #ffd7da;
      display: none; white-space: pre-wrap;
    }

    .topControls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .inline { display: flex; gap: 12px; align-items: center; }
    .inline > * { flex: 1; }

    .editorGrid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: start; margin-top: 12px; }
    .canvasWrap { display: grid; gap: 8px; }
    .canvasFrame {
      border: 1px solid #2a2a2a; border-radius: 12px; padding: 10px; background: #0b0b0b;
    }
    canvas { display: block; width: 100%; height: auto; image-rendering: pixelated; border-radius: 8px; }
    .canvasMeta { display: flex; justify-content: space-between; gap: 12px; align-items: baseline; }

    .toolRow { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-top: 10px; }

    /* Slider */
    .sliderWrap { display: grid; gap: 6px; }
    input[type="range"] {
      width: 100%;
      height: 32px; margin: 0;
      touch-action: none;
      cursor: pointer;
      background: transparent;
    }

    /* Right panel list */
    .rightHeader { display: flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .recentControls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px; }
    .recentList { display: grid; gap: 10px; margin-top: 12px; }
    .item {
      border: 1px solid #232323; border-radius: 12px; padding: 10px;
      background: #0f0f0f; display: grid; gap: 8px;
      cursor: pointer;
    }
    .item:hover { border-color: #3a3a3a; }
    .itemHead { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: start; }
    .itemName { font-weight: 750; }
    .itemMeta { color: #9a9a9a; font-size: 12px; }
    .itemStats { color: #bdbdbd; font-size: 12px; text-align: right; }
    .miniFrame { border: 1px solid #232323; border-radius: 10px; padding: 8px; background: #000; }
    .miniCanvas { width: 100%; height: auto; image-rendering: pixelated; border-radius: 6px; display:block; }

    /* Bottom controls */
    .bottomControls { margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .fileMeta { padding: 10px; border-radius: 10px; border: 1px solid #232323; background: #0d0d0d; }
  </style>
</head>

<body>
  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="topControls">
        <div>
          <label for="shapeName">Shape name</label>
          <input id="shapeName" type="text" placeholder="e.g., the donut" />
        </div>

        <div>
          <label>Shading mode</label>
          <select id="shadingMode">
            <option value="solid">Solid colour</option>
            <option value="1">1block colour (n×m)</option>
            <option value="2">2block colour (2n×2m)</option>
            <option value="3">3block colour (3n×3m)</option>
            <option value="4">4block colour (4n×4m)</option>
          </select>
          <div class="muted">In pixel modes, thick lines = blocks; thin lines = pixels.</div>
        </div>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div class="inline">
          <div>
            <label>Colour</label>
            <div class="inline">
              <input id="paintColor" type="color" value="#ff00e6" />
              <div class="mono" id="paintColorHex">#ff00e6</div>
            </div>
            <div class="muted" id="colorHelp">Used for painting pixels and for solid mode.</div>
          </div>
          <div>
            <label for="shapeDifficulty">Difficulty</label>
            <select id="shapeDifficulty">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2" selected>2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
            <div class="muted">0–4 (default 2).</div>
          </div>
        </div>

        <div>
          <div class="sliderWrap">
            <label for="shapeFreq">Frequency: <span class="mono" id="freqVal">1.00</span></label>
            <input id="shapeFreq" type="range" min="0" max="1" step="0.01" value="1.00" />
            <div class="muted">0.00–1.00</div>
          </div>
          <div style="margin-top:10px;">
            <button id="saveBtn" class="primary" disabled>Save shape</button>
            <div class="muted" style="margin-top:8px;">
              Click a shape on the right to load and edit. Grid-structure duplicates are allowed (no grid conflict check).
            </div>
          </div>
        </div>
      </div>

      <div class="toolRow">
        <div>
          <label>Grid size</label>
          <div class="inline">
            <input id="gridW" type="number" min="1" max="20" step="1" value="3" />
            <input id="gridH" type="number" min="1" max="20" step="1" value="3" />
          </div>
          <div class="muted">Width × height in blocks (n×m).</div>
        </div>
        <div>
          <label>Mask tools</label>
          <div class="inline">
            <button id="maskFillBtn">Fill X</button>
            <button id="maskClearBtn">Clear</button>
          </div>
          <div class="muted">Mask defines X vs empty blocks.</div>
        </div>
        <div>
          <label>Colour tools</label>
          <div class="inline">
            <button id="paintBtn" class="primary">Paint</button>
            <button id="eraseBtn">Erase</button>
            <button id="clearPaintBtn">Clear</button>
          </div>
          <div class="muted">Erase paints empty (“”).</div>
        </div>
      </div>

      <div class="editorGrid">
        <div class="canvasWrap">
          <div class="canvasMeta">
            <div style="font-weight:800;">Mask (blocks)</div>
            <div class="muted mono" id="maskDims">—</div>
          </div>
          <div class="canvasFrame">
            <canvas id="maskCanvas" width="520" height="360"></canvas>
          </div>
          <div class="muted">Click/drag to toggle blocks. Mask edits auto-clear colour pixels in empty blocks.</div>
        </div>

        <div class="canvasWrap">
          <div class="canvasMeta">
            <div style="font-weight:800;">Colour (pixels on black)</div>
            <div class="muted mono" id="pixDims">—</div>
          </div>
          <div class="canvasFrame">
            <canvas id="paintCanvas" width="520" height="360"></canvas>
          </div>
          <div class="muted">In solid mode, this is a preview only; colour saved as a single hex string.</div>
        </div>
      </div>

      <div class="error" id="errorBox"></div>

      <!-- Bottom -->
      <div class="bottomControls">
        <div>
          <label for="shapeId">Shape id (optional)</label>
          <input id="shapeId" type="text" placeholder="(auto-suggested from name)" />
          <div class="muted">Auto-suggest: longest word in name (ties resolved by later words), lowercased.</div>
        </div>

        <div>
          <label>Target file</label>
          <div class="inline">
            <button id="pickFileBtn">Pick file…</button>
            <button id="reloadBtn" disabled>Reload</button>
          </div>
          <div class="fileMeta">
            <div><b>Selected:</b> <span id="fileName" class="mono">None</span></div>
            <div class="muted" id="fileInfo">Default path: <span class="mono">./shapes/main_shapes.js</span> (loads for browsing if served).</div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="rightHeader">
        <div style="font-weight:800;">Shapes</div>
        <div class="muted"><span id="shapeCount">0</span> total</div>
      </div>

      <div class="recentControls">
        <div>
          <label for="pageSize">Show</label>
          <input id="pageSize" type="number" min="5" max="200" step="5" value="25" />
        </div>
        <div>
          <label>Page</label>
          <div class="inline">
            <button id="prevPageBtn">Prev</button>
            <button id="nextPageBtn">Next</button>
          </div>
        </div>
        <div>
          <label>Status</label>
          <div class="fileMeta">
            <div class="mono" id="pageLabel">Page 1 / 1</div>
            <div class="muted">Newest first</div>
          </div>
        </div>
      </div>

      <div id="recentList" class="recentList"></div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // -----------------------------
  // State
  // -----------------------------
  let fileHandle = null;
  let loadedText = null;
  let loadedShapes = null;

  const DEFAULT_REL_PATH = "./shapes/main_shapes.js";
  const HANDLE_DB_NAME = "shape_builder_advanced_fs_handles";
  const HANDLE_DB_STORE = "handles";
  const HANDLE_KEY = "shapesFileHandle";

  let currentFreq = 1.0;

  let pageIndex = 0;
  let pageSize = 25;

  // Mask: n rows × m cols (height × width) booleans
  let nW = 3, nH = 3;
  let mask = make2D(nH, nW, true);

  // Pixel shading factor k (1..4); "solid" handled separately
  let shading = "solid"; // "solid" or "1".."4"
  let k = 1;

  // pixels: (k*nH) rows × (k*nW) cols of hex strings or ""
  let pixels = make2D(k*nH, k*nW, "");

  // paint mode
  let paintMode = "paint"; // "paint" or "erase"

  // canvas
  const maskCanvas = $("maskCanvas");
  const paintCanvas = $("paintCanvas");
  const maskCtx = maskCanvas.getContext("2d");
  const paintCtx = paintCanvas.getContext("2d");

  // drawing state
  let isDraggingMask = false;
  let isDraggingPaint = false;

  // -----------------------------
  // Helpers
  // -----------------------------
  function showError(msg) {
    const el = $("errorBox");
    if (!msg) { el.style.display = "none"; el.textContent = ""; return; }
    el.style.display = "block";
    el.textContent = msg;
  }

  function normaliseNewlines(s) {
    return s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  }

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

  function escapeHtml(str) {
    return String(str).replace(/[&<>"']/g, (m) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  function make2D(h, w, fillVal) {
    const arr = new Array(h);
    for (let r = 0; r < h; r++) {
      arr[r] = new Array(w);
      for (let c = 0; c < w; c++) arr[r][c] = (typeof fillVal === "function") ? fillVal(r,c) : fillVal;
    }
    return arr;
  }

  function deepCopy2D(a) { return a.map(row => row.slice()); }

  function suggestIdFromName(name) {
    const parts = name
      .trim()
      .split(/\s+/)
      .filter(Boolean)
      .map(w => w.replace(/[^A-Za-z0-9_'-]/g, ""))
      .filter(Boolean);
    if (parts.length === 0) return "";
    let best = parts[0];
    for (const w of parts) {
      if (w.length > best.length) best = w;
      else if (w.length === best.length) best = w; // later wins
    }
    return best.toLowerCase().replace(/['-]/g, "").replace(/[^a-z0-9_]/g, "_");
  }

  function syncFreqFromSlider() {
    const v = clamp(parseFloat($("shapeFreq").value), 0, 1);
    currentFreq = Number.isFinite(v) ? v : 1.0;
    $("freqVal").textContent = currentFreq.toFixed(2);
  }

  function enhanceRangeDragging(rangeEl) {
    rangeEl.addEventListener("pointerdown", (e) => { try { rangeEl.setPointerCapture(e.pointerId); } catch (_) {} });
    rangeEl.addEventListener("pointerup", (e) => { try { rangeEl.releasePointerCapture(e.pointerId); } catch (_) {} });
  }

  function setShadingMode(mode) {
    shading = mode;
    if (mode === "solid") {
      k = 1;
      // keep pixels as-is but rendering becomes preview-only
    } else {
      k = clamp(parseInt(mode, 10), 1, 4);
      // resize pixels to k*nH × k*nW, preserving overlap where possible
      const newH = k * nH;
      const newW = k * nW;
      const next = make2D(newH, newW, "");
      const minH = Math.min(newH, pixels.length);
      const minW = Math.min(newW, pixels[0]?.length || 0);
      for (let r = 0; r < minH; r++) for (let c = 0; c < minW; c++) next[r][c] = pixels[r][c];
      pixels = next;
      // clear pixels in empty blocks
      clearPixelsInEmptyBlocks();
    }
    renderAll();
  }

  function setGridSize(newW, newH) {
    newW = clamp(newW, 1, 20);
    newH = clamp(newH, 1, 20);

    // resize mask preserving overlap
    const nextMask = make2D(newH, newW, false);
    const minH = Math.min(newH, mask.length);
    const minW = Math.min(newW, mask[0]?.length || 0);
    for (let r = 0; r < minH; r++) for (let c = 0; c < minW; c++) nextMask[r][c] = mask[r][c];

    nW = newW; nH = newH;
    mask = nextMask;

    // resize pixels based on current shading
    if (shading === "solid") {
      // keep pixels array but update to k=1 dims for a sensible preview canvas
      k = 1;
    } else {
      k = clamp(parseInt(shading, 10), 1, 4);
    }

    const newPH = k * nH;
    const newPW = k * nW;
    const nextPix = make2D(newPH, newPW, "");
    const pMinH = Math.min(newPH, pixels.length);
    const pMinW = Math.min(newPW, pixels[0]?.length || 0);
    for (let r = 0; r < pMinH; r++) for (let c = 0; c < pMinW; c++) nextPix[r][c] = pixels[r][c];
    pixels = nextPix;

    clearPixelsInEmptyBlocks();
    renderAll();
  }

  function clearPixelsInEmptyBlocks() {
    if (shading === "solid") return;
    const pH = k * nH;
    const pW = k * nW;
    for (let br = 0; br < nH; br++) {
      for (let bc = 0; bc < nW; bc++) {
        if (!mask[br][bc]) {
          for (let pr = br*k; pr < br*k + k; pr++) {
            for (let pc = bc*k; pc < bc*k + k; pc++) {
              if (pr < pH && pc < pW) pixels[pr][pc] = "";
            }
          }
        }
      }
    }
  }

  function maskToGridStrings() {
    const rows = [];
    for (let r = 0; r < nH; r++) {
      let s = "";
      for (let c = 0; c < nW; c++) s += mask[r][c] ? "X" : ".";
      rows.push(s);
    }
    return rows;
  }

  function inferModeFromShape(shape) {
    // Returns { shadingMode, k, pixels2DOrNull, solidColorOrNull }
    const grid = Array.isArray(shape.grid) ? shape.grid : [];
    const h = grid.length || 1;
    const w = (grid[0] || "").length || 1;

    // mask from grid
    const newMask = make2D(h, w, false);
    for (let r = 0; r < h; r++) {
      const line = grid[r] || "";
      for (let c = 0; c < w; c++) newMask[r][c] = (line[c] === "X");
    }

    const col = shape.color;

    if (typeof col === "string") {
      return { nW: w, nH: h, mask: newMask, shadingMode: "solid", k: 1, pixels: null, solid: col };
    }

    // If it's a 2D array: infer factor by dimensions
    if (Array.isArray(col) && Array.isArray(col[0])) {
      const pH = col.length;
      const pW = col[0].length;
      const factorH = Math.round(pH / h);
      const factorW = Math.round(pW / w);
      const factor = clamp(Math.min(factorH, factorW), 1, 4);

      // normalise to rectangular
      const norm = make2D(factor*h, factor*w, "");
      for (let r = 0; r < norm.length; r++) {
        for (let c = 0; c < norm[0].length; c++) {
          const v = (col[r] && col[r][c] != null) ? col[r][c] : "";
          norm[r][c] = (typeof v === "string") ? v : "";
        }
      }

      return { nW: w, nH: h, mask: newMask, shadingMode: String(factor), k: factor, pixels: norm, solid: null };
    }

    // Fallback: treat as solid with default colour
    return { nW: w, nH: h, mask: newMask, shadingMode: "solid", k: 1, pixels: null, solid: "#ffffff" };
  }

  // -----------------------------
  // Rendering (better system)
  // -----------------------------
  function renderMaskCanvas() {
    const W = maskCanvas.width;
    const H = maskCanvas.height;
    maskCtx.clearRect(0, 0, W, H);

    // background black
    maskCtx.fillStyle = "#000";
    maskCtx.fillRect(0, 0, W, H);

    const cell = computeCellSize(W, H, nW, nH);
    const offX = Math.floor((W - cell * nW) / 2);
    const offY = Math.floor((H - cell * nH) / 2);

    // blocks
    for (let r = 0; r < nH; r++) {
      for (let c = 0; c < nW; c++) {
        const x = offX + c*cell;
        const y = offY + r*cell;
        maskCtx.fillStyle = mask[r][c] ? "#f2f2f2" : "#111";
        maskCtx.fillRect(x, y, cell, cell);
      }
    }

    // grid lines bold (blocks)
    maskCtx.strokeStyle = "rgba(255,255,255,0.35)";
    maskCtx.lineWidth = 2;
    maskCtx.beginPath();
    for (let c = 0; c <= nW; c++) {
      const x = offX + c*cell;
      maskCtx.moveTo(x, offY);
      maskCtx.lineTo(x, offY + nH*cell);
    }
    for (let r = 0; r <= nH; r++) {
      const y = offY + r*cell;
      maskCtx.moveTo(offX, y);
      maskCtx.lineTo(offX + nW*cell, y);
    }
    maskCtx.stroke();

    $("maskDims").textContent = `${nW}×${nH}`;
  }

  function renderPaintCanvas() {
    const W = paintCanvas.width;
    const H = paintCanvas.height;
    paintCtx.clearRect(0, 0, W, H);

    // background black
    paintCtx.fillStyle = "#000";
    paintCtx.fillRect(0, 0, W, H);

    const factor = (shading === "solid") ? 1 : k;
    const pW = factor * nW;
    const pH = factor * nH;

    const cell = computeCellSize(W, H, pW, pH);
    const offX = Math.floor((W - cell * pW) / 2);
    const offY = Math.floor((H - cell * pH) / 2);

    // draw pixels or solid preview
    const solid = $("paintColor").value.toLowerCase();

    for (let r = 0; r < pH; r++) {
      for (let c = 0; c < pW; c++) {
        const x = offX + c*cell;
        const y = offY + r*cell;

        // mask block coords
        const br = Math.floor(r / factor);
        const bc = Math.floor(c / factor);
        const filled = (mask[br] && mask[br][bc]) ? true : false;

        if (!filled) {
          // invisible area remains black (subtle checker)
          paintCtx.fillStyle = ((r + c) % 2 === 0) ? "#050505" : "#070707";
          paintCtx.fillRect(x, y, cell, cell);
          continue;
        }

        let col;
        if (shading === "solid") {
          col = solid;
        } else {
          col = pixels[r]?.[c] || "";
          if (!col) {
            paintCtx.fillStyle = "#000";
            paintCtx.fillRect(x, y, cell, cell);
            continue;
          }
        }
        paintCtx.fillStyle = col;
        paintCtx.fillRect(x, y, cell, cell);
      }
    }

    // pixel grid lines (thin)
    paintCtx.strokeStyle = "rgba(255,255,255,0.18)";
    paintCtx.lineWidth = 1;
    paintCtx.beginPath();
    for (let c = 0; c <= pW; c++) {
      const x = offX + c*cell;
      paintCtx.moveTo(x, offY);
      paintCtx.lineTo(x, offY + pH*cell);
    }
    for (let r = 0; r <= pH; r++) {
      const y = offY + r*cell;
      paintCtx.moveTo(offX, y);
      paintCtx.lineTo(offX + pW*cell, y);
    }
    paintCtx.stroke();

    // block boundaries (bold)
    paintCtx.strokeStyle = "rgba(255,255,255,0.45)";
    paintCtx.lineWidth = 2;
    paintCtx.beginPath();
    for (let bc = 0; bc <= nW; bc++) {
      const x = offX + (bc*factor)*cell;
      paintCtx.moveTo(x, offY);
      paintCtx.lineTo(x, offY + pH*cell);
    }
    for (let br = 0; br <= nH; br++) {
      const y = offY + (br*factor)*cell;
      paintCtx.moveTo(offX, y);
      paintCtx.lineTo(offX + pW*cell, y);
    }
    paintCtx.stroke();

    $("pixDims").textContent = (shading === "solid") ? `${nW}×${nH} (solid)` : `${pW}×${pH} (k=${k})`;
  }

  function computeCellSize(canvasW, canvasH, gridW, gridH) {
    const pad = 6;
    const maxW = canvasW - pad*2;
    const maxH = canvasH - pad*2;
    return Math.max(6, Math.floor(Math.min(maxW / gridW, maxH / gridH)));
  }

  function renderAll() {
    renderMaskCanvas();
    renderPaintCanvas();
    updateListPanel();
  }

  // -----------------------------
  // Canvas coordinate mapping
  // -----------------------------
  function getCanvasCellFromEvent(evt, canvas, gridW, gridH) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (canvas.height / rect.height);

    const cell = computeCellSize(canvas.width, canvas.height, gridW, gridH);
    const offX = Math.floor((canvas.width - cell * gridW) / 2);
    const offY = Math.floor((canvas.height - cell * gridH) / 2);

    const cx = Math.floor((x - offX) / cell);
    const cy = Math.floor((y - offY) / cell);

    if (cx < 0 || cy < 0 || cx >= gridW || cy >= gridH) return null;
    return { c: cx, r: cy };
  }

  // -----------------------------
  // Painting logic
  // -----------------------------
  function applyMaskAt(evt) {
    const cell = getCanvasCellFromEvent(evt, maskCanvas, nW, nH);
    if (!cell) return;
    const { r, c } = cell;
    mask[r][c] = !mask[r][c];
    clearPixelsInEmptyBlocks();
    renderAll();
  }

  function applyPaintAt(evt) {
    // solid mode: do nothing (preview only)
    if (shading === "solid") return;

    const pW = k * nW;
    const pH = k * nH;
    const cell = getCanvasCellFromEvent(evt, paintCanvas, pW, pH);
    if (!cell) return;

    const { r, c } = cell;
    const br = Math.floor(r / k);
    const bc = Math.floor(c / k);

    if (!mask[br][bc]) return; // cannot paint invisible blocks

    if (paintMode === "erase") {
      pixels[r][c] = "";
    } else {
      pixels[r][c] = $("paintColor").value.toLowerCase();
    }
    renderPaintCanvas();
  }

  // -----------------------------
  // File parsing / serialisation
  // -----------------------------
  function findMatchingBracket(s, openPos, openCh, closeCh) {
    let depth = 0, inStr = false, strCh = null, escape = false;
    for (let i = openPos; i < s.length; i++) {
      const c = s[i];
      if (inStr) {
        if (escape) { escape = false; continue; }
        if (c === "\\") { escape = true; continue; }
        if (c === strCh) { inStr = false; strCh = null; }
        continue;
      } else {
        if (c === "'" || c === '"' || c === "`") { inStr = true; strCh = c; continue; }
      }
      if (c === openCh) depth++;
      else if (c === closeCh) { depth--; if (depth === 0) return i; }
    }
    return -1;
  }

  function extractAndEvalShapes(jsText) {
    const text = normaliseNewlines(jsText);
    const m = text.match(/export\s+const\s+SHAPES\s*=\s*\[/m);
    if (!m) throw new Error("Could not find `export const SHAPES = [` in the file.");

    const startIdx = m.index + m[0].length - 1;
    const endIdx = findMatchingBracket(text, startIdx, "[", "]");
    if (endIdx < 0) throw new Error("Could not find the end of the SHAPES array.");

    const arrayLiteral = text.slice(startIdx, endIdx + 1);

    let shapes;
    try {
      shapes = (new Function(`"use strict"; return (${arrayLiteral});`))();
    } catch (e) {
      throw new Error("SHAPES exists but could not be evaluated (non-literal code inside array?).");
    }

    if (!Array.isArray(shapes)) throw new Error("Parsed SHAPES is not an array.");
    return shapes;
  }

  function jsString(s) {
    const esc = String(s).replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\n/g, "\\n");
    return `'${esc}'`;
  }

  function jsObject(obj) {
    if (obj && typeof obj === "object" && !Array.isArray(obj)) {
      const entries = Object.entries(obj).map(([k,v]) => `${k}: ${jsValue(v)}`);
      return `{ ${entries.join(", ")} }`;
    }
    return "{}";
  }

  function jsArray(arr) {
    // Handles 1D or 2D arrays of strings/numbers
    if (!Array.isArray(arr)) return "[]";
    const items = arr.map(v => jsValue(v));
    return `[${items.join(", ")}]`;
  }

  function jsValue(v) {
    if (v == null) return "null";
    if (typeof v === "string") return jsString(v);
    if (typeof v === "number" && Number.isFinite(v)) return String(v);
    if (typeof v === "boolean") return v ? "true" : "false";
    if (Array.isArray(v)) return jsArray(v);
    if (typeof v === "object") return jsObject(v);
    return jsString(String(v));
  }

  function serialiseShapes(shapes) {
    const lines = [];
    lines.push("export const SHAPES = [");
    for (const s of shapes) {
      lines.push("  {");
      lines.push(`    id: ${jsString(s.id)},`);
      lines.push(`    name: ${jsString(s.name)},`);
      lines.push(`    grid: ${jsArray(s.grid)},`);
      lines.push(`    color: ${jsValue(s.color)},`);
      lines.push(`    difficulty: ${clamp(parseInt(s.difficulty ?? 2, 10), 0, 4)},`);
      lines.push(`    rotation: ${jsObject(s.rotation || { mode: "any" })},`);
      lines.push(`    frequency: ${clamp(Number(s.frequency ?? 1), 0, 1).toFixed(2)},`);
      lines.push("  },");
    }
    lines.push("];");
    lines.push("");
    return lines.join("\n");
  }

  function replaceShapesArrayInText(originalText, newShapesFileContent) {
    const text = normaliseNewlines(originalText);
    const re = /export\s+const\s+SHAPES\s*=\s*\[[\s\S]*?\]\s*;\s*/m;
    if (re.test(text)) return text.replace(re, newShapesFileContent);
    return newShapesFileContent;
  }

  // -----------------------------
  // File I/O
  // -----------------------------
  async function loadFromText(text, fileLabel) {
    loadedText = text;
    loadedShapes = extractAndEvalShapes(text);

    $("fileName").textContent = fileLabel || "Loaded";
    $("fileInfo").textContent = `Loaded ${loadedShapes.length} shape(s).`;
    $("saveBtn").disabled = !fileHandle;

    updateListPanel();
  }

  async function tryFetchDefaultForBrowsing() {
    try {
      const res = await fetch(DEFAULT_REL_PATH, { cache: "no-store" });
      if (!res.ok) return;
      const text = await res.text();
      await loadFromText(text, DEFAULT_REL_PATH);
    } catch (_) {}
  }

  async function writeBack(updatedText) {
    if (fileHandle && fileHandle.createWritable) {
      try {
        const writable = await fileHandle.createWritable();
        await writable.write(updatedText);
        await writable.close();
        return { method: "in_place" };
      } catch (_) {}
    }

    const blob = new Blob([updatedText], { type: "text/javascript;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = fileHandle ? fileHandle.name : "main_shapes.js";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    return { method: "download" };
  }

  async function pickFile() {
    if (!window.showOpenFilePicker) {
      alert("Use Chrome/Edge for direct writing. Otherwise you can browse default if served, but saving will be download-only.");
      return;
    }
    const [handle] = await window.showOpenFilePicker({
      multiple: false,
      types: [{ description: "JavaScript files", accept: { "text/javascript": [".js"] } }]
    });
    fileHandle = handle;
    await persistHandle(handle);
    await reloadFromFile();
    $("reloadBtn").disabled = false;
    $("saveBtn").disabled = false;
  }

  async function reloadFromFile() {
    if (!fileHandle) throw new Error("No file selected.");
    const file = await fileHandle.getFile();
    const text = await file.text();
    await loadFromText(text, fileHandle.name);
  }

  // -----------------------------
  // Persist file handle
  // -----------------------------
  function openHandleDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(HANDLE_DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(HANDLE_DB_STORE)) db.createObjectStore(HANDLE_DB_STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function persistHandle(handle) {
    try {
      const db = await openHandleDb();
      await new Promise((resolve, reject) => {
        const tx = db.transaction(HANDLE_DB_STORE, "readwrite");
        tx.objectStore(HANDLE_DB_STORE).put(handle, HANDLE_KEY);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
      db.close();
    } catch (_) {}
  }

  async function restoreHandleIfPossible() {
    if (!window.showOpenFilePicker) return false;
    try {
      const db = await openHandleDb();
      const handle = await new Promise((resolve, reject) => {
        const tx = db.transaction(HANDLE_DB_STORE, "readonly");
        const req = tx.objectStore(HANDLE_DB_STORE).get(HANDLE_KEY);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
      db.close();
      if (!handle) return false;

      let perm = await handle.queryPermission({ mode: "readwrite" });
      if (perm !== "granted") perm = await handle.requestPermission({ mode: "readwrite" });
      if (perm !== "granted") return false;

      fileHandle = handle;
      await reloadFromFile();
      $("reloadBtn").disabled = false;
      $("saveBtn").disabled = false;
      return true;
    } catch (_) {
      return false;
    }
  }

  // -----------------------------
  // Conflicts (NO grid conflict check anymore)
  // -----------------------------
  function hasConflicts(shapes, newShape) {
    const idConflict = shapes.find(s => s.id === newShape.id) || null;
    const nameConflict = shapes.find(s => s.name === newShape.name) || null;
    return { idConflict, nameConflict };
  }

  async function resolveConflictsAndApply(shapes, newShape) {
    const { idConflict, nameConflict } = hasConflicts(shapes, newShape);
    if (!idConflict && !nameConflict) return { action: "add", shapes: [...shapes, newShape] };

    const parts = [];
    if (idConflict) parts.push(`• ID already exists: "${newShape.id}"`);
    if (nameConflict) parts.push(`• Name already exists: "${newShape.name}"`);
    const msg =
      "Conflict detected:\n\n" + parts.join("\n") +
      "\n\nOK = override\nCancel = choose Add/cancel";

    const okOverride = window.confirm(msg);
    if (okOverride) {
      const updated = shapes.map(s => {
        if (idConflict && s.id === newShape.id) return newShape;
        if (!idConflict && nameConflict && s.name === newShape.name) return newShape;
        return s;
      });
      return { action: "override", shapes: updated };
    }

    const okAdd = window.confirm("Add anyway?\n\nOK = add\nCancel = cancel");
    if (!okAdd) return { action: "cancel", shapes };
    return { action: "add_anyway", shapes: [...shapes, newShape] };
  }

  // -----------------------------
  // Build shape object from editor
  // -----------------------------
  function buildShapeFromUI() {
    const name = $("shapeName").value.trim() || "(unnamed)";
    let id = $("shapeId").value.trim();
    if (!id) {
      id = suggestIdFromName(name);
      if (!id || id === "unnamed") throw new Error("Please provide a shape id (auto-id not useful for an empty/unnamed name).");
    }
    if (!/^[a-z0-9_]+$/.test(id)) throw new Error("ID must contain only lowercase letters, numbers, and underscores.");

    const grid = maskToGridStrings();

    const freq = clamp(Number(currentFreq), 0, 1);
    const diff = clamp(parseInt($("shapeDifficulty").value, 10), 0, 4);

    let colorOut;
    if (shading === "solid") {
      colorOut = $("paintColor").value.toLowerCase();
    } else {
      // output 2D array pH×pW, with "" for empty pixels (and empty blocks already blanked)
      colorOut = deepCopy2D(pixels);
    }

    return {
      id,
      name,
      grid,
      color: colorOut,
      difficulty: diff,
      rotation: { mode: "any" },
      frequency: freq,
    };
  }

  // -----------------------------
  // Right panel (pagination + previews)
  // -----------------------------
  function getShapesNewestFirst() {
    const shapes = Array.isArray(loadedShapes) ? loadedShapes : [];
    return shapes.slice().reverse();
  }

  function updatePaginationLabel(total) {
    const pageCount = Math.max(1, Math.ceil(total / pageSize));
    pageIndex = clamp(pageIndex, 0, pageCount - 1);
    $("pageLabel").textContent = `Page ${pageIndex + 1} / ${pageCount}`;
    $("prevPageBtn").disabled = (pageIndex === 0);
    $("nextPageBtn").disabled = (pageIndex >= pageCount - 1);
  }

  function drawMiniPreview(shape, canvas) {
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    const grid = Array.isArray(shape.grid) ? shape.grid : ["X"];
    const h = grid.length || 1;
    const w = (grid[0] || "").length || 1;

    // mask
    const localMask = make2D(h, w, false);
    for (let r = 0; r < h; r++) {
      const line = grid[r] || "";
      for (let c = 0; c < w; c++) localMask[r][c] = (line[c] === "X");
    }

    const col = shape.color;

    let factor = 1;
    let pix = null;
    let solid = "#ffffff";

    if (typeof col === "string") {
      factor = 1;
      solid = col.toLowerCase();
    } else if (Array.isArray(col) && Array.isArray(col[0])) {
      const pH = col.length;
      const pW = col[0].length;
      factor = clamp(Math.round(Math.min(pH / h, pW / w)), 1, 4);
      // normalise
      pix = make2D(factor*h, factor*w, "");
      for (let r = 0; r < pix.length; r++) for (let c = 0; c < pix[0].length; c++) pix[r][c] = (col[r] && typeof col[r][c] === "string") ? col[r][c] : "";
    }

    const drawW = factor * w;
    const drawH = factor * h;
    const cell = Math.max(1, Math.floor(Math.min((W-8)/drawW, (H-8)/drawH)));
    const offX = Math.floor((W - cell*drawW)/2);
    const offY = Math.floor((H - cell*drawH)/2);

    for (let r = 0; r < drawH; r++) {
      for (let c = 0; c < drawW; c++) {
        const br = Math.floor(r / factor);
        const bc = Math.floor(c / factor);
        if (!localMask[br][bc]) continue;

        let fill = solid;
        if (pix) fill = pix[r][c] || "";
        if (!fill) continue;

        ctx.fillStyle = fill;
        ctx.fillRect(offX + c*cell, offY + r*cell, cell, cell);
      }
    }
  }

  function updateListPanel() {
    const list = $("recentList");
    list.innerHTML = "";

    const newest = getShapesNewestFirst();
    $("shapeCount").textContent = String(newest.length);

    updatePaginationLabel(newest.length);
    if (newest.length === 0) {
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No shapes loaded yet.";
      list.appendChild(empty);
      return;
    }

    const start = pageIndex * pageSize;
    const end = Math.min(newest.length, start + pageSize);
    const pageItems = newest.slice(start, end);

    for (const s of pageItems) {
      const item = document.createElement("div");
      item.className = "item";
      item.title = "Click to load into editor";

      const head = document.createElement("div");
      head.className = "itemHead";

      const left = document.createElement("div");
      left.innerHTML = `
        <div class="itemName">${escapeHtml(s.name || "(unnamed)")}</div>
        <div class="itemMeta mono">id: ${escapeHtml(s.id || "(none)")}</div>
      `;

      const freq = Number(s.frequency);
      const freqText = Number.isFinite(freq) ? freq.toFixed(2) : "—";
      const diff = Number(s.difficulty);
      const diffText = Number.isFinite(diff) ? String(diff) : "—";

      const modeText = (() => {
        if (typeof s.color === "string") return "solid";
        if (Array.isArray(s.color) && Array.isArray(s.color[0])) {
          const h = (s.grid?.length || 1);
          const w = (s.grid?.[0]?.length || 1);
          const pH = s.color.length;
          const pW = s.color[0].length;
          const factor = clamp(Math.round(Math.min(pH / h, pW / w)), 1, 4);
          return `${factor}x`;
        }
        return "?";
      })();

      const right = document.createElement("div");
      right.className = "itemStats mono";
      right.innerHTML = `f=${freqText}<br/>d=${diffText}<br/>${modeText}`;

      head.appendChild(left);
      head.appendChild(right);

      const frame = document.createElement("div");
      frame.className = "miniFrame";
      const mini = document.createElement("canvas");
      mini.className = "miniCanvas";
      mini.width = 220;
      mini.height = 120;
      frame.appendChild(mini);

      item.appendChild(head);
      item.appendChild(frame);

      drawMiniPreview(s, mini);

      item.addEventListener("click", () => loadShapeIntoEditor(s));

      list.appendChild(item);
    }
  }

  function loadShapeIntoEditor(shape) {
    // infer mask + mode + pixels
    const inf = inferModeFromShape(shape);

    // set size/mask
    $("gridW").value = String(inf.nW);
    $("gridH").value = String(inf.nH);
    nW = inf.nW; nH = inf.nH;
    mask = inf.mask;

    // name/id
    $("shapeName").value = shape.name ?? "";
    $("shapeId").value = shape.id ?? "";

    // difficulty/frequency
    const diff = clamp(parseInt(shape.difficulty ?? 2, 10), 0, 4);
    $("shapeDifficulty").value = String(diff);

    const freq = clamp(Number(shape.frequency ?? 1), 0, 1);
    currentFreq = freq;
    $("shapeFreq").value = String(freq);
    $("freqVal").textContent = freq.toFixed(2);

    // shading + pixels/solid
    if (inf.shadingMode === "solid") {
      $("shadingMode").value = "solid";
      shading = "solid";
      k = 1;
      $("paintColor").value = (inf.solid || "#ffffff").toLowerCase();
      $("paintColorHex").textContent = $("paintColor").value.toLowerCase();

      // keep a pixels buffer sized to mask for preview
      pixels = make2D(nH, nW, "");
    } else {
      $("shadingMode").value = inf.shadingMode;
      shading = inf.shadingMode;
      k = inf.k;
      pixels = inf.pixels ? deepCopy2D(inf.pixels) : make2D(k*nH, k*nW, "");
      clearPixelsInEmptyBlocks();
    }

    // update paint dims labels and redraw
    showError("");
    renderAll();
  }

  // -----------------------------
  // Events
  // -----------------------------
  $("paintColor").addEventListener("input", () => {
    $("paintColorHex").textContent = $("paintColor").value.toLowerCase();
    renderPaintCanvas();
  });

  $("shadingMode").addEventListener("change", () => {
    setShadingMode($("shadingMode").value);
  });

  $("gridW").addEventListener("change", () => {
    setGridSize(parseInt($("gridW").value, 10) || 1, nH);
  });
  $("gridH").addEventListener("change", () => {
    setGridSize(nW, parseInt($("gridH").value, 10) || 1);
  });

  $("maskFillBtn").addEventListener("click", () => {
    mask = make2D(nH, nW, true);
    clearPixelsInEmptyBlocks();
    renderAll();
  });
  $("maskClearBtn").addEventListener("click", () => {
    mask = make2D(nH, nW, false);
    clearPixelsInEmptyBlocks();
    renderAll();
  });

  $("paintBtn").addEventListener("click", () => {
    paintMode = "paint";
    $("paintBtn").classList.add("primary");
    $("eraseBtn").classList.remove("primary");
  });
  $("eraseBtn").addEventListener("click", () => {
    paintMode = "erase";
    $("eraseBtn").classList.add("primary");
    $("paintBtn").classList.remove("primary");
  });
  $("clearPaintBtn").addEventListener("click", () => {
    if (shading === "solid") return;
    pixels = make2D(k*nH, k*nW, "");
    clearPixelsInEmptyBlocks();
    renderAll();
  });

  $("shapeName").addEventListener("input", () => {
    const name = $("shapeName").value.trim();
    const idField = $("shapeId");
    if (!idField.value.trim() && name) idField.placeholder = suggestIdFromName(name) || "(auto-suggested from name)";
  });

  $("shapeFreq").addEventListener("input", syncFreqFromSlider);
  $("shapeFreq").addEventListener("change", syncFreqFromSlider);
  enhanceRangeDragging($("shapeFreq"));

  // Mask canvas interactions
  maskCanvas.addEventListener("pointerdown", (e) => {
    isDraggingMask = true;
    maskCanvas.setPointerCapture(e.pointerId);
    applyMaskAt(e);
  });
  maskCanvas.addEventListener("pointermove", (e) => {
    if (!isDraggingMask) return;
    // For mask, moving toggles repeatedly is annoying; instead only toggle on down.
    // So do nothing on move.
  });
  maskCanvas.addEventListener("pointerup", (e) => {
    isDraggingMask = false;
    try { maskCanvas.releasePointerCapture(e.pointerId); } catch (_) {}
  });

  // Paint canvas interactions
  paintCanvas.addEventListener("pointerdown", (e) => {
    isDraggingPaint = true;
    paintCanvas.setPointerCapture(e.pointerId);
    applyPaintAt(e);
  });
  paintCanvas.addEventListener("pointermove", (e) => {
    if (!isDraggingPaint) return;
    applyPaintAt(e);
  });
  paintCanvas.addEventListener("pointerup", (e) => {
    isDraggingPaint = false;
    try { paintCanvas.releasePointerCapture(e.pointerId); } catch (_) {}
  });

  // Pagination
  $("pageSize").addEventListener("input", () => {
    const v = clamp(parseInt($("pageSize").value, 10) || 25, 5, 200);
    pageSize = v;
    $("pageSize").value = String(v);
    pageIndex = 0;
    updateListPanel();
  });
  $("prevPageBtn").addEventListener("click", () => {
    pageIndex = Math.max(0, pageIndex - 1);
    updateListPanel();
  });
  $("nextPageBtn").addEventListener("click", () => {
    const total = getShapesNewestFirst().length;
    const pageCount = Math.max(1, Math.ceil(total / pageSize));
    pageIndex = Math.min(pageCount - 1, pageIndex + 1);
    updateListPanel();
  });

  // File pick/reload
  $("pickFileBtn").addEventListener("click", async () => {
    try { await pickFile(); showError(""); }
    catch (e) { showError(e.message || String(e)); }
  });
  $("reloadBtn").addEventListener("click", async () => {
    try { await reloadFromFile(); showError(""); }
    catch (e) { showError(e.message || String(e)); }
  });

  // Save
  $("saveBtn").addEventListener("click", async () => {
    try {
      if (!loadedText || !loadedShapes) throw new Error("No shapes loaded. Pick a file (or serve project so default loads).");

      const newShape = buildShapeFromUI();
      const resolved = await resolveConflictsAndApply(loadedShapes, newShape);
      if (resolved.action === "cancel") return;

      const newShapesBlock = serialiseShapes(resolved.shapes);
      const updatedText = replaceShapesArrayInText(loadedText, newShapesBlock);

      await writeBack(updatedText);

      await loadFromText(updatedText, fileHandle ? fileHandle.name : (DEFAULT_REL_PATH + " (updated)"));
      pageIndex = 0;
      updateListPanel();
      showError("");
    } catch (e) {
      showError(e.message || String(e));
    }
  });

  // -----------------------------
  // Boot
  // -----------------------------
  (async () => {
    $("paintColorHex").textContent = $("paintColor").value.toLowerCase();
    syncFreqFromSlider();

    // attempt restore handle
    const restored = await restoreHandleIfPossible();
    if (!restored) {
      await tryFetchDefaultForBrowsing();
      $("saveBtn").disabled = true;
      $("fileInfo").textContent =
        "Browse works if served and ./shapes/main_shapes.js is reachable. Pick the file once to enable fast in-place saving (no re-select).";
    } else {
      $("reloadBtn").disabled = false;
      $("saveBtn").disabled = false;
    }

    // initial render
    $("gridW").value = String(nW);
    $("gridH").value = String(nH);
    $("shadingMode").value = "solid";
    setShadingMode("solid");
    renderAll();
  })();
})();
</script>
</body>
</html>